#!/usr/bin/env python

import os, sys, shutil
os.environ["CUDA_VISIBLE_DEVICES"]="1"

import rospy
import roslib
import numpy as np
import h5py

import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D, SeparableConv2D
from keras.models import load_model,Model

from message_repository.srv import ActionnessProposal,ActionnessProposalResponse
from message_repository.srv import ActionClassifier,ActionClassifierResponse


## class: actionness proposal
class PoseNetActionnessProposal:
	def __init__(self, num_classes, input_shape):
		self.num_classes = num_classes
		self.input_shape = input_shape
		self.model_actionness = []
		return

	def actionnessModel(self):
		model = Sequential()
		model.add(Conv2D(64, (3, 2), activation='relu', input_shape=self.input_shape))
		print(model.output_shape)
		model.add(MaxPooling2D(pool_size=(2, 2), strides=1))
		print(model.output_shape)
		model.add(Conv2D(128, (3, 2), activation='relu'))
		print(model.output_shape)
		model.add(MaxPooling2D(pool_size=(2, 2), strides=1))
		model.add(Flatten())
		model.add(Dense(1024, activation='relu',name='Dense1'))
		model.add(Dense(self.num_classes, activation='softmax',name='SoftMax'))
		print(model.summary())
	
		return model

	def initModel(self, preTrained_model):
		self.model_actionness = self.actionnessModel()
		self.model_actionness = load_model(preTrained_model)
		self.model_actionness.predict(np.zeros((1,)+self.input_shape)) 

		return


	def actionnessLabelCallback(self, req):
		rospy.loginfo("Actionness Proposal Callback")
		
		# convert msg to numpy array 
		pose_tensor = multiArrayToMatrixList(req.tensor)
		input_shape = pose_tensor.shape
		pose_tensor = np.expand_dims(pose_tensor, axis=0)
		
		print "input shape: ", input_shape
		print "tensor shape: ", pose_tensor.shape	
		
		# configure params and make prediction
		label_prob = self.model_actionness.predict(pose_tensor)
		actionness_label = int(np.argmax(label_prob, axis=1)+1)
		
		rospy.loginfo("actionness label: %d", actionness_label)
		print " "
		
		return ActionnessProposalResponse(actionness_label)


## class: action classifier
class PoseNetClassifier:
	def __init__(self, num_classes, input_shape):
		self.num_classes = num_classes
		self.input_shape = input_shape
		self.model_classifier = []
		return

	def classifierModel(self):
		model = Sequential()
		model.add(Conv2D(64, (3, 2), activation='relu', input_shape=self.input_shape))
		print(model.output_shape)
		model.add(MaxPooling2D(pool_size=(2, 2), strides=1))
		print(model.output_shape)
		model.add(Conv2D(128, (3, 2), activation='relu'))
		print(model.output_shape)
		model.add(MaxPooling2D(pool_size=(2, 2), strides=1))
		model.add(Flatten())
		model.add(Dense(1024, activation='relu',name='Dense1'))
		model.add(Dense(self.num_classes, activation='softmax',name='SoftMax'))
		print(model.summary())
	
		return model

	def initModel(self, preTrained_model):
		self.model_classifier = self.classifierModel()
		self.model_classifier = load_model(preTrained_model)
		self.model_classifier.predict(np.zeros((1,)+self.input_shape))

		return


	def actionLabelCallback(self, req):
		rospy.loginfo("Action Classification Callback")
		
		# convert msg to numpy array 
		pose_tensor = multiArrayToMatrixList(req.tensor)
		input_shape = pose_tensor.shape
		pose_tensor = np.expand_dims(pose_tensor, axis=0)
		
		print "input shape: ", input_shape
		print "tensor shape: ", pose_tensor.shape	
		
		# configure params and make prediction
		label_prob = self.model_classifier.predict(pose_tensor)
		action_label = int(np.argmax(label_prob, axis=1)+1)
		
		rospy.loginfo("action label: %d", action_label)
		print " "
		
		return ActionClassifierResponse(action_label)


## convert MultiArray message into a list of numpy matrix
def multiArrayToMatrixList(ma_msg):
	dim = len(ma_msg.layout.dim)
	offset = ma_msg.layout.data_offset

	if dim != 3:
		print "Error: Must be 3 dimensions"

	if (ma_msg.layout.dim[0].label != "frame"):
	  	print "Error: dim[0] should be the frames"
	num_frames = ma_msg.layout.dim[0].size

	if (ma_msg.layout.dim[1].label != "node"):
	  	print "Error: dim[1] should be the pose nodes"
	num_nodes = ma_msg.layout.dim[1].size

	if (ma_msg.layout.dim[2].label != "channel"):
	  	print "Error: dim[2] should be the channels"
	num_channels = ma_msg.layout.dim[2].size

	tensor_shape = (num_frames, num_nodes, num_channels)
	pose_tensor = np.empty(tensor_shape)
	pose_tensor.fill(np.nan)
	data_index = 0
	
	for i in range(0, num_frames):
	 	 for j in range(0, num_nodes):
			for k in range(0, num_channels):
		  		pose_tensor[i,j,k] = ma_msg.data[data_index]
		  		data_index += 1 

	return pose_tensor


## service initialization
def pose_net_server():
	rospy.init_node('pose_net')
	
	## init model 
	preTrained_model_actionness = "/home/nvidia/MasterThesis/code/ros_pipeline/data/airport_5735half_fc2_pose.h5"
	preTrained_model_classifier = "/home/nvidia/MasterThesis/code/ros_pipeline/data/airport_5735half_fc2_pose.h5"
	
	# model shape and class numbers
	input_shape_actionness = (10,54,3)
	input_shape_classifier = (10,54,3) 
	num_classes_actionness = 4
	num_classes_classifier = 4
	
	## declare service
	actionness_proposal = PoseNetActionnessProposal(num_classes=num_classes_actionness, input_shape=input_shape_actionness)
	actionness_proposal.initModel(preTrained_model=preTrained_model_actionness)
	service_actionness = rospy.Service('actionness_proposal', ActionnessProposal, actionness_proposal.actionnessLabelCallback)

	classifier = PoseNetClassifier(num_classes=num_classes_classifier, input_shape=input_shape_classifier)
	classifier.initModel(preTrained_model=preTrained_model_classifier)
	service_classifier = rospy.Service('action_classifier', ActionClassifier, classifier.actionLabelCallback)

	rospy.loginfo("Initialization Successful!")
	rospy.loginfo("PoseNet Action Proposal and Classification Server is ready, waiting for request ...")
	print(" ")
	
	rospy.spin()
	
	return
	

if __name__ == "__main__":
	print("PoseNet -- Action Proposal And Classification Server")
	print("----------------------------------------------------")
	pose_net_server()	








